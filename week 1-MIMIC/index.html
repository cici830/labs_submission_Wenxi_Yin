<!DOCTYPE html>
<html>
<head>
 
      <script>
        window.onerror = function(error, url, line) {
          parent.postMessage(["console", "\"Error on line[" + (line-1) + "]:" + error + "\""], "*")
        };
        window.addEventListener("unhandledrejection", function (event) {
          parent.postMessage(["console", "\"Error:Uncaught " + event.reason + "\""], "*")
        });
        function prettyPrint(obj, indent = 0, seen = new Map()) {
          
          let result = '';
          let baseIndent = ' '.repeat(indent);
          let newIndent = baseIndent + '    ';
          try {
          if (seen.has(obj)) {
              return `${baseIndent}"[Circular Reference (${seen.get(obj)})]"`;
          }
      
          if (typeof obj === 'object' && obj !== null) {
              seen.set(obj, seen.size + 1);
      
              if (Array.isArray(obj)) {
                  result += '[';
                  for (let i = 0; i < obj.length; i++) {
                      if (i > 0) {
                          result += ',';
                      }
                      const value = obj[i];
                      if (typeof value === 'object' && value !== null) {
                          result += '\n' + prettyPrint(value, indent + 4, seen);
                      } else if (typeof value === 'string') {
                          result += `\n${newIndent}"${value}"`;
                      } else if (typeof value === 'function') {
                        result += `\n${newIndent}"[Function]"`;
                      }  else if (value === undefined) {
                        result += `\n${newIndent}"[undefined]"`;
                      }
                      else {
                        result += `\n${newIndent}${value}`;
                      }
                  }
                  result += `\n${baseIndent}]`;
              } else {
                  result += '{\n';
                  let entries = Object.keys(obj).map((key) => {
                      const value = obj[key];
                      let entry = `${newIndent}"${key}": `;
                      if (typeof value === 'object' && value !== null) {
                          entry += prettyPrint(value, indent + 4, seen);
                      } else if (typeof value === 'string') {
                          entry += `"${value}"`;
                      } else if (typeof value === 'function') {
                        entry += `\n${newIndent}"[Function]"`;
                      } else if (value === undefined) {
                        entry += `\n${newIndent}"[undefined]"`;
                      } else {
                          entry += value;
                      }
      
                      return entry;
                  });
      
                  result += entries.join(',\n');
                  result += `\n${baseIndent}}`;
              }
          } else {
              if (typeof obj === 'string') {
                  result += `"${obj}"`;
              } else {
                  result += obj.toString();
              }
          }
        } catch (err) {
          result = "error making json string"
        }
      
          return result;
      }
        </script><script language="javascript" type="text/javascript">
let pacMan;
let dots = [];
let ghosts = [];
let gameOver = false;
let win = false;
let restartButton;
let maze;
let ghostImage; // Variable to hold the ghost image

function preload() {
  // Load the ghost image
  ghostImage = loadImage('ghostImage.png');
  playerImage = loadImage('playerImage.png');
}

function setup() {
  createCanvas(800, 800);

  // Create button
  restartButton = createButton('Restart');
  restartButton.position(width / 2 - 50, height / 2 + 50);
  restartButton.mousePressed(restartGame);
  restartButton.hide();

  // Create Pacman and initial dots
  pacMan = new Pacman();
  maze = new Maze();
  refreshDots(maze);
  createGhosts(maze);
}

function draw() {
  background(0);

  // Display maze
  maze.display();

  if (!gameOver && !win) {
    // Display and update dots
    for (let dot of dots) {
      dot.update();
      dot.display();
    }

    // Display and update ghosts
    for (let ghost of ghosts) {
      ghost.update();
      ghost.display();
      if (pacMan.collide(ghost)) {
        gameOver = true;
      }
    }

    // Update and display Pacman
    pacMan.update();
    pacMan.display();

    // Check for collisions with dots
    for (let i = dots.length - 1; i >= 0; i--) {
      if (pacMan.eat(dots[i])) {
        dots.splice(i, 1);
      }
    }

    // Check if all dots are eaten
    if (dots.length === 0) {
      win = true;
    }
  } else {
    if (win) {
      textSize(32);
      fill(255);
      textAlign(CENTER, CENTER);
      text('You Win!', width / 2, height / 2 - 30);
    } else {
      textSize(32);
      fill(255);
      textAlign(CENTER, CENTER);
      text('Game Over', width / 2, height / 2 - 30);
    }
    restartButton.show();
  }
}

function refreshDots(maze) {
  dots = []; // Clear existing dots
  for (let i = 0; i < 30; i++) {
    let valid = false;
    let x, y;
    while (!valid) {
      x = random(width);
      y = random(height);
      valid = true;
      // Check if the position collides with any wall
      for (let wall of maze.walls) {
        if (wall.intersects(x - 5, y - 5, 10, 10)) {
          valid = false;
          break;
        }
      }
    }
    dots.push(new MovingDot(x, y));
  }
}

function createGhosts(maze) {
  ghosts = []; // Clear existing ghosts
  for (let i = 0; i < 2; i++) {
    let valid = false;
    let x, y;
    while (!valid) {
      x = random(width);
      y = random(height);
      valid = true;
      // Check if the position collides with any wall
      for (let wall of maze.walls) {
        if (wall.intersects(x - 15, y - 15, 30, 30)) {
          valid = false;
          break;
        }
      }
    }
    ghosts.push(new Ghost(x, y));
  }
}

function restartGame() {
  win = false;
  gameOver = false;
  restartButton.hide();
  pacMan.reset();
  refreshDots(maze);
  createGhosts(maze);
}

class Pacman {
  constructor() {
    this.x = width / 2;
    this.y = height / 2;
    this.radius = 20;
    this.angleStart = 0.2;
    this.angleEnd = TWO_PI - 0.2;
  }

  display() {
    imageMode(CENTER);
    // Display Pacman
    image(playerImage, this.x, this.y, this.radius * 2, this.radius * 2);
  }

  update() {
    let newX = this.x;
    let newY = this.y;

    if (keyIsDown(UP_ARROW)) {
      newY = this.y - 5;
    } else if (keyIsDown(DOWN_ARROW)) {
      newY = this.y + 5;
    }

    if (keyIsDown(LEFT_ARROW)) {
      newX = this.x - 5;
    } else if (keyIsDown(RIGHT_ARROW)) {
      newX = this.x + 5;
    }

    // Check if the new position collides with any wall
    let hitWall = false;
    for (let wall of maze.walls) {
      if (wall.intersects(newX - this.radius, newY - this.radius, this.radius * 2, this.radius * 2)) {
        hitWall = true;
        break;
      }
    }

    // Update position only if no collision with walls
    if (!hitWall) {
      this.x = newX;
      this.y = newY;
    }
  }

  eat(dot) {
    let d = dist(this.x, this.y, dot.x, dot.y);
    if (d < this.radius + dot.radius) {
      return true;
    } else {
      return false;
    }
  }

  collide(ghost) {
    let d = dist(this.x, this.y, ghost.x, ghost.y);
    if (d < this.radius + ghost.radius) {
      return true;
    } else {
      return false;
    }
  }

  reset() {
    this.x = width / 2;
    this.y = height / 2;
  }
}

class MovingDot {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.radius = 5;
    this.directionX = random(-1, 1);
    this.directionY = random(-1, 1);
    this.speed = 2;
  }

  display() {
    fill(255);
    noStroke();
    ellipse(this.x, this.y, this.radius * 2, this.radius * 2);
  }

  update() {
    // Move randomly
    let newX = this.x + this.directionX * this.speed;
    let newY = this.y + this.directionY * this.speed;

    // Check if the new position collides with any wall
    let hitWall = false;
    for (let wall of maze.walls) {
      if (wall.intersects(newX - this.radius, newY - this.radius, this.radius * 2, this.radius * 2)) {
        hitWall = true;
        break;
      }
    }

    // Update position only if no collision with walls
    if (!hitWall) {
      this.x = newX;
      this.y = newY;
    } else {
      // Reverse direction if hit wall
      this.directionX *= -1;
      this.directionY *= -1;
    }
  }
}

class Ghost {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.radius = 15;
    this.speed = 2;
    this.directionX = random(-1, 1);
    this.directionY = random(-1, 1);
  }

  display() {
    imageMode(CENTER);
    // Display Ghost
    image(ghostImage, this.x, this.y, this.radius * 2, this.radius * 2);
  }

  update() {
    // Move randomly
    let newX = this.x + this.directionX * this.speed;
    let newY = this.y + this.directionY * this.speed;

    // Check if the new position collides with any wall
    let hitWall = false;
    for (let wall of maze.walls) {
      if (wall.intersects(newX - this.radius, newY - this.radius, this.radius * 2, this.radius * 2)) {
        hitWall = true;
        break;
      }
    }

    // Update position only if no collision with walls
    if (!hitWall) {
      this.x = newX;
      this.y = newY;
    } else {
      // Change direction randomly if hit wall
      this.directionX = random(-1, 1);
      this.directionY = random(-1, 1);
    }
  }
}

class Maze {
  constructor() {
    this.walls = [];
    // Define your maze here
    // For example:
    this.walls.push(new Wall(0, 0, width, 20)); // Top border
    this.walls.push(new Wall(0, 0, 20, height)); // Left border
    this.walls.push(new Wall(0, height - 20, width, 20)); // Bottom border
    this.walls.push(new Wall(width - 20, 0, 20, height)); // Right border

    // Inner walls
    this.walls.push(new Wall(100, 100, 20, 300));
    this.walls.push(new Wall(200, 100, 300, 20));
    this.walls.push(new Wall(200, 200, 20, 300));
    this.walls.push(new Wall(100, 500, 200, 20));
    this.walls.push(new Wall(500, 200, 20, 200));
    this.walls.push(new Wall(400, 300, 300, 20));
    this.walls.push(new Wall(700, 100, 20, 600));
    this.walls.push(new Wall(400, 500, 300, 20));

    // Additional walls to ensure no dead ends
    this.walls.push(new Wall(200, 500, 20, 300));
    this.walls.push(new Wall(400, 100, 300, 20));

    // Extra walls to provide more openings
    this.walls.push(new Wall(300, 300, 100, 20));
    this.walls.push(new Wall(500, 300, 100, 20));
    this.walls.push(new Wall(200, 400, 100, 20));
    this.walls.push(new Wall(500, 400, 100, 20));
  }

  display() {
    for (let wall of this.walls) {
      wall.display();
    }
  }
}

class Wall {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }

  display() {
    fill(100);
    rect(this.x, this.y, this.w, this.h);
  }

  intersects(x, y, w, h) {
    return !(x + w < this.x || y + h < this.y || x > this.x + this.w || y > this.y + this.h);
  }
}
</script>
 <script crossorigin src = "../libs/p5.min.js">
</script>
</head>
<body>
<script language="javascript" type="text/javascript">

</script>
</body>
</html>